# coding: utf-8
from PySide import QtCore
import threading

from translator.config import Config, Translation
from translator import Engine
from db import models

# ---------------------------------------------------------------------------------------------------------------------
class Interface(QtCore.QObject):
    start = QtCore.Signal(str)  # Issued at the beginning of the thread processing the Job.
    end = QtCore.Signal(models.Translation)  # issued at the end of the thread processing the Job.
    error = QtCore.Signal(str)  # issued when an exception was raised in the Job processing thread.

# ---------------------------------------------------------------------------------------------------------------------
class Job(threading.Thread):
    """
     The interface makes processing occurs outside the main thread and allows you
    to return the reply by issuing the event generated by the signal.
    """

    _db_access_lock = threading.Lock()

    def __init__(self, text, signal):
        super(Job, self).__init__()
        self.signal = signal
        self.text = text

    def _cache_related(self, cls, query):
        """ database cache """
        for _cls in cls:
            grammaticalclass = models.GrammaticalClass(name=_cls["name"], translation=query)
            grammaticalclass.save()

            for name in _cls['words']:
                name = name.strip()
                word = models.Word(name=name, grammaticalClass=grammaticalclass)
                word.save()

                for name in _cls["details"][name]:
                    name = name.strip()
                    obj, created = models.ReverseWord.objects.get_or_create(name=name)
                    word.reversewords.add(obj)

    def _cache_data(self, simple, cls):
        """ database cache """
        query, created = models.Translation.objects.get_or_create(
            source=simple[0],
            target=simple[1],
            sourceLocale='en',
            targetLocale='pt'
        )
        # If you have already created a new process would be a mistake.
        if created:
            self._cache_related(cls, query)
        return query

    def run(self):
        try:
            self.signal.start.emit('start')

            translation = Translation(self.text, 'en', 'pt')
            config = Config(translation)
            engine = Engine(config)

            related = engine.transl()
            simple = related.get("simple", [])
            classes = related.get("class", [])

            # protecting the database against concurrent access.
            with self._db_access_lock:
                query = self._cache_data(simple, classes)
        except Exception as err:
            self.signal.error.emit(str(err))
        else:
            self.signal.end.emit(query)
